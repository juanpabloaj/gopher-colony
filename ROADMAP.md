# ROADMAP.md

## Project Overview
This document outlines the development stages for **Gopher Colony**. The approach is incremental: each phase builds upon the previous one, delivering a self-contained, deployable artifact before increasing complexity.

The primary goal is to simulate a production environment. Therefore, every phase implies the inclusion of necessary testing, documentation, and error handling mechanisms required for a stable release.

---

## Phase 1: Foundation and Connectivity
**Objective:** Establish the architectural skeleton, HTTP/WebSocket infrastructure, and robust connection lifecycle management.

**Scope:**
*   Project directory structure initialization following the defined architecture.
*   Implementation of the HTTP server and WebSocket handshake endpoints.
*   Integration of structured logging.
*   Connection lifecycle management: Handling successful connections, graceful shutdowns, and unexpected disconnections.
*   Basic Multi-room support: Ability to route a connection to a specific logical context (room/lobby).

**Deliverable:**
A running server application where clients can connect, maintain a persistent session, and disconnect cleanly without server errors.

**Validation Scenarios:**
*   **Connectivity:** A client can establish a WebSocket connection to a specific room ID.
*   **Concurrency:** Multiple clients can connect simultaneously to different rooms without blocking each other.
*   **Resilience:** Forcing a client disconnect triggers the appropriate cleanup logic on the server logs.

---

## Phase 2: World Representation and Visualization
**Objective:** Define the core domain models and establish the initial state synchronization between Server and Client.

**Scope:**
*   **Domain Modeling:** Definition of the World, Grid, and Tile entities.
*   **Map Generation:** Logic to initialize a grid with varying terrain types (ground, water, obstacles).
*   **State Serialization:** Mechanism to convert the internal server state into a format suitable for network transmission (Protocol definition).
*   **Client Rendering:** Frontend logic to parse the initial state and render the grid using static characters/icons.

**Deliverable:**
A visual interface where a connected client immediately sees the current state of the game map generated by the server.

**Validation Scenarios:**
*   **Consistency:** Refreshing the browser renders the exact same map state (assuming persistence or seeded generation).
*   **Representation:** Terrain types defined in the backend (e.g., Water vs. Land) are visually distinct in the frontend.

---

## Phase 3: Interactive State Mutation
**Objective:** Enable real-time user interaction and propagate changes to all participants (Broadcasting).

**Scope:**
*   **Command Processing:** Implementation of a pattern to handle user inputs (e.g., "Click at X,Y").
*   **Business Logic Validation:** Rules engine to verify if an action is legal (e.g., cannot build on water).
*   **Concurrency Management:** ensuring safe access to shared world state during simultaneous modifications.
*   **Broadcasting:** Pattern to notify all clients within a room when the state changes.

**Deliverable:**
A multiplayer prototype where an action performed by one user (e.g., changing a terrain tile) is instantly reflected on the screens of all other users in the same room.

**Validation Scenarios:**
*   **Synchronization:** User A modifies a tile; User B sees the update immediately.
*   **Isolation:** User A in Room 1 modifies a tile; User C in Room 2 sees no change.
*   **Constraint Enforcement:** User attempts an invalid action; the server rejects it, and no change is broadcast.

---

## Phase 4: The Simulation Loop
**Objective:** Introduce server-authoritative autonomy, allowing the world to evolve without user intervention.

**Scope:**
*   **Game Loop:** Implementation of a central ticker that advances the game time.
*   **Entity Lifecycle:** Modeling entities as State Machines (e.g., Sapling -> Tree).
*   **Delta Updates:** Optimizing network traffic by sending only changed tiles rather than the full map state on every tick.

**Deliverable:**
A dynamic world where entities grow, decay, or interact automatically over time based on server logic.

**Validation Scenarios:**
*   **Automation:** An entity changes appearance/state after a specific duration without any user input.
*   **Efficiency:** Network monitoring shows that data is transmitted only when a state change actually occurs, not on every tick.

---

## Phase 5: Economy and Logistics
**Objective:** Implement complex gameplay systems involving resource management and autonomous agents.

**Scope:**
*   **Player Inventory:** System to track resource ownership.
*   **Resource Extraction:** Logic for converting map entities into inventory items.
*   **Transportation:** Mechanics for moving resources between coordinates (e.g., paths or autonomous carriers).
*   **Trading:** Interface for resource exchange between connected players.

**Deliverable:**
A playable simulation game with a complete loop: Gather -> Transport -> Trade/Build.

**Validation Scenarios:**
*   **Accumulation:** Harvesting a resource removes it from the map and adds it to the player's counter.
*   **Transport:** A resource visually moves from Point A to Point B over time.
*   **Transaction:** A trade between Player A and Player B correctly updates both inventories atomically.
